#+OPTIONS: toc:nil num:nil
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [8pt,a4paper]


#+TITLE: Python essential 2 sur skillforall.com

* modules, packages, and pip

# tous les modules python standard :
# https://docs.python.org/3/py-modindex.html


| import math                             |                                                                      |
| import sys                              |                                                                      |
|-----------------------------------------+----------------------------------------------------------------------|
| import math, sys                        | importation de module sur une seule ligne                            |
|-----------------------------------------+----------------------------------------------------------------------|
| import math                             |                                                                      |
| math.pi                                 | 3.141592653589793                                                    |
|-----------------------------------------+----------------------------------------------------------------------|
| import math as m                        | alias                                                                |
| math.pi                                 | *NameError*                                                          |
| m.pi                                    | 3.141592653589793                                                    |
| dir(m)                                  | toutes les fn & const possibles [...  pi, 'sinh', 'sqrt', 'tan' ...] |
|-----------------------------------------+----------------------------------------------------------------------|
| from math import pi                     | seulement pi est importé                                             |
| math.pi                                 | *NameError* name 'math' is not defined                              |
| pi                                      | 3.141592653589793                                                    |
| pi = "hello"                            | "hello"                                                              |
|-----------------------------------------+----------------------------------------------------------------------|
| from math import pi as PI               |                                                                      |
| pi                                      | *NameError*                                                          |
| PI                                      | 3.141592653589793                                                    |
|-----------------------------------------+----------------------------------------------------------------------|
| from math import pi as pie, sin as sine |                                                                      |
| pie                                     | 3.141592653589793                                                    |
| sine(pie/2)                             | 1.0                                                                  |
|-----------------------------------------+----------------------------------------------------------------------|
| from math import *                      |                                                                      |
| sin(pi/2)                               | 1.0                                                                  |
|-----------------------------------------+----------------------------------------------------------------------|
| import math                             |                                                                      |
| dir(math)                               | toutes les fn & const possibles [...  pi, 'sinh', 'sqrt', 'tan' ...] |
|                                         |                                                                      |



#+begin_src python :session :results output
"""
import XXX           -> XXX.myfunc -> voie recommandée
from XXX import YYY  -> YYY        -> déconseillée pour éviter les pbs de conflits de variables
"""

import math
from math import pi as pie, sin as sine
print(math.pi)
print(pie)
print(sine(pie/2))
print(dir(math)[:10])
#+end_src

#+RESULTS:
: 3.141592653589793
: 3.141592653589793
: 1.0
: ['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh']


#+begin_src python :session :results output
from math import pi, radians, degrees, sin, cos, tan, asin
print(degrees(radians(90)))
print(radians(90) == pi/2)
#+end_src

#+RESULTS:
: 90.0
: True
: 1.106186954104004


** module math

*pow(x,y) : x puissance y*
peut être appelé directement sans importer math :
mais peut etre également appelé via le module math

import math puis math.pow(x,y)


*abs(x)*
valeur absolue n'est pas dans math


| sin(x)       |                                          |
| cos(x)       |                                          |
| tan(x)       |                                          |
| asin(x)      | arcsine de x                             |
| acos(x)      |                                          |
| atan(x)      |                                          |
| pi           |                                          |
| radians(x)   | converti degré en radian                 |
| degrees(x)   | converti radian en degré                 |
| sinh(x)      | hyperbolic sine                          |
| cosh(x)      |                                          |
| tanh(x)      |                                          |
| asinh(x)     |                                          |
| acosh(x)     |                                          |
| atanh(x)     |                                          |
|--------------+------------------------------------------|
| e            | constante de euler                       |
| exp(x)       | e puissance x                            |
| log(x)       |                                          |
| log(x,b)     | logarithm de x à la base b               |
| log10(x)     | logarithm décimal de x                   |
| log2(x)      | logarithm binaire de x                   |
|--------------+------------------------------------------|
| ceil         | arrondi entier supérieur                 |
| floor(x)     | x // 1  arrondi entier inférieur         |
| trunc(x)     | partie entière                           |
| factorial(x) | éq x! en math                            |
| hypot(x,y)   | longueur de l'hypoténuse (via pythagore) |
|              |                                          |



#+begin_src python :session :results output
from math import ceil, floor, trunc
x=1.1
y=2.6
print(floor(x), floor(y))
print(floor(-x), floor(-y))
print(ceil(x), ceil(y))
print(ceil(-x), ceil(-y))
print(trunc(x), trunc(y))
print(trunc(-x), trunc(-y))
#+end_src

#+RESULTS:
: 1 2
: -2 -3
: 2 3
: -1 -2
: 1 2
: -1 -2

** module random

| from random import random, seed, randrange, randint |                                                    |
|-----------------------------------------------------+----------------------------------------------------|
| random()                                            | float entre 0.0 et 1.0 non compris                 |
|-----------------------------------------------------+----------------------------------------------------|
| seed()                                              | met le seed sur l'heure courante                   |
| seed(int)                                           | fixe le seed -> random.random() devient prévisible |
|-----------------------------------------------------+----------------------------------------------------|
| randrange(end)                                      | valeur entière, end *non inclus* car "range"       |
| randrange(beg, end)                                 |                                                    |
| randrange(beg, end, step)                           |                                                    |
|-----------------------------------------------------+----------------------------------------------------|
| randint(beg, end)                                   | valeur entière, end *inclus*                       |
|-----------------------------------------------------+----------------------------------------------------|
| choice(seq)                                         | choisi un au hasard dans la list ou tuple          |
| sample(seq, n)                                      | [] avec n éléments choisis au hasard               |
|                                                     |                                                    |


#+begin_src python :session :results output
from random import random, seed, choice, sample
seed(0)
print(random() == 0.8444218515250481) 
print(random() == 0.7579544029403025)
seed()
print(random())

tup = (1,2,3,4,5)
print(choice(tup))
print(sample(tup, 2))
#+end_src

#+RESULTS:
: True
: True
: 0.6619319105111775
: 4
: [2, 3]

** module platform

| from platform import *  |                                      |
|-------------------------+--------------------------------------|
| platform()              | system() + machine() + processor()   |
| system()                | linux                                |
| machine()               | x86                                  |
| processor()             | 64 bits                              |
| version()               | smp preempt dynamic 7 janvier 2023   |
|-------------------------+--------------------------------------|
| python_implementation() | nom de l'implémentation de Python    |
| python_version_tuple()  | Python version (major, minor, patch) |
|                         |                                      |

#+begin_src python :session :results output
from platform import platform, machine, processor, system, version, python_implementation, python_version_tuple
print("platform", platform())
print("machine", machine())
print("processor", processor())
print("system", system())
print("version", version())
print("python_implementation", python_implementation())
print("python_version_tuple", python_version_tuple())
#+end_src

#+RESULTS:
: platform Linux-6.0.18-200.fc36.x86_64-x86_64-with-glibc2.35
: machine x86_64
: processor x86_64
: system Linux
: version #1 SMP PREEMPT_DYNAMIC Sat Jan 7 17:08:48 UTC 2023
: python_implementation CPython
: python_version_tuple ('3', '10', '10')


** package = groupe de modules = répertoire


*pour faire un package*

- créer un répertoire /home/thai/python/my_package
- créer my_package/__init__.py
- créer des fichiers .py et des sous répertoires à my_package


*pour utiliser un package*

from sys import path
path.append le répertoire contenant tous les packages
import my_package.<fichier avec la fonction désirée>


#+begin_src python :session :results output
"""
répertoire des packages : /home/thai/checkout/python/formation/lab
2 manières de l'utiliser :

import my_package.iota
my_package.iota.FunI()

vs

from my_package.iota import FunI
FunI()
"""

from sys import path
path.append("/home/thai/checkout/python/formation/lab")

import my_package.iota
print(my_package.iota.FunI())

from my_package.good.alpha import FunA
print(FunA())
#+end_src

#+RESULTS:
: Iota
: Alpha



| #!/usr/bin/env python3 | shebang                                                                           |
|------------------------+-----------------------------------------------------------------------------------|
| import <module>        | exécute le contenu du module *une seule* fois même si plusieurs import            |
|------------------------+-----------------------------------------------------------------------------------|
| *__pycache__*          | code semi compilé .pyc créé automatiquement lors de l'import du module par python |
|------------------------+-----------------------------------------------------------------------------------|
| *__name__*             | vaut <module> si on est dans un module sinon vaut __main__                        |
|                        | ex usecase : lance des tests unitaires si appelé directement                      |
|------------------------+-----------------------------------------------------------------------------------|
| <module>._mycount      | convention : on met un ou deux underscore devant une variable dans le module      |
| <module>.myfunc(x)     |                                                                                   |
|------------------------+-----------------------------------------------------------------------------------|
| *__init__.py*          | à mettre à la *racine* du package                                                 |
|------------------------+-----------------------------------------------------------------------------------|
| as                     | alias                                                                             |
|                        | import my_package.iota as io                                                      |
|                        |                                                                                   |

** module sys

| from sys import *                              |                                                                    |
| path                                           | [] avec des directory et .zip (gère les zip comme des répertoires) |
|------------------------------------------------+--------------------------------------------------------------------|
| path.append("/path/to/module_dir")             | ajoute le module au path pour pouvoir l'importer                   |
| path.append("\\path\\to\\windows\\module_dir") |                                                                    |
| import module                                  |                                                                    |
|------------------------------------------------+--------------------------------------------------------------------|
| path.append("/path/to/module_dir/pack.zip")    | pack.zip contient my_package/iota.py                               |
| from my_package.iota import FunI               | on l'utilise normalement                                           |
|------------------------------------------------+--------------------------------------------------------------------|
| exit()                                         |                                                                    |


** pip (pip installs packages) = python package installer = permet de browser le repo PyPI (python package index)
# PyPI est managé par le Packaging Working Group de la Python Software Fondation
# https://pypi.org
# ~ 315k projets et ~520k users
# on peut créer son propre repo également

| pip                                | package installer résolvant les dépendances     |
| pip help                           |                                                 |
| pip --version                      |                                                 |
| pip --user ...                     | en tant que user local                          |
|------------------------------------+-------------------------------------------------|
| pip list                           | liste tous les packages et la version installés |
| pip show <installed package>       | metadata + dependencies                         |
| https://pypi.org/search            | recherche de package                            |
|------------------------------------+-------------------------------------------------|
| pip install -U <installed package> | maj à la dernière version                       |
| pip install pygame==1.9.2          | install une version particulière                |
| pip uninstall pygame               |                                                 |


* strings, string and list methods, exceptions

** python est internationalisé compatible unicode

# encodage de caractères = ascii ou unicode
# codepoint = le numéro associé au caractère
# stockage des caractères unicode = ucs-4 ou utf-8 (le plus optimal en terme d'espace)


| ASCII                | 256 caractères                                                                   |
| i18n                 | internationalisation                                                             |
|                      | " " = code point 32                                                              |
|                      | "A" = code point 65                                                              |
|                      | "a" = code point 97 (65+32=92)                                                   |
|                      |                                                                                  |
| code point 0 - 127   | standard latin alphabet                                                          |
| code point 127 - 256 | dépend du code page ex. iso/iec8859-2 ou iso/iec8859-5                           |
|----------------------+----------------------------------------------------------------------------------|
| unicode              | +1 million de code points pour avoir des caractères uniques                      |
|                      | 0-127 : identique à ascii                                                        |
|                      | 127-256 : identique à iso/iec8859-1                                              |
|----------------------+----------------------------------------------------------------------------------|
| ucs-4                | universal character set : standard décrivant l'implémentation de l'unicode       |
|                      | chaque caractère est stocké sur 32 bits (4 bytes)                                |
| bom                  | byte order mark, bits invisibles décrivant la nature du contenu du fichier ucs-4 |
|----------------------+----------------------------------------------------------------------------------|
| utf-8                | unicode transformation format, taille variable                                   |
|                      | caractères latins sont stockés sur 8 bits                                        |
|                      | caractères non latins sur 16 bits                                                |
|                      | cjk china-japan-korea sur 24 bits                                                |


** string = sequences immutable

comme c'est une sequence on peut
- *slicer* [:]
- *indexer* [n]
- *itérer* for i in
- *comparer*
  x in
  x not in


comme c'est immutable, on ne peut pas
- *supprimer* del x[n]
  par contre on a le droit de faire del x pour supprimer le nom de variable
- *ajouter* x.append()
- *insérer* x.insert(i,n)

| """               | str multiligne                    |
| '''               |                                   |
|-------------------+-----------------------------------|
| + *               | + concaténer                      |
|                   | * répliquer                       |
| 'a' + 'b'         | 'ab'                              |
| 'a' * 2           | 'aa'                              |
|-------------------+-----------------------------------|
| *=                | s'applique aussi aux str          |
| +=                |                                   |
|-------------------+-----------------------------------|
| ord(x)            | caractère -> code point           |
| chr(n)            | code point -> caractère           |
| chr(ord(x)) == x  | True                              |
| ord(chr(x)) == x  | True                              |
|-------------------+-----------------------------------|
| x[begin:end:step] |                                   |
| "abcdef"[::2]     | "ace"                             |
|-------------------+-----------------------------------|
| min()             | penser ascii table                |
| max()             |                                   |
|-------------------+-----------------------------------|
| min("abc")        | "a"                               |
| min("aA")         | "A"                               |
| min(" aA")        | " "                               |
| min("")           | *ValueError*                      |
|-------------------+-----------------------------------|
| list("abc")       | ["a","b","c"]                     |
|-------------------+-----------------------------------|
| len("\n\n")       | 2                                 |
|-------------------+-----------------------------------|
| "ab".index("a")   | index du *premier* élément trouvé |
| "ab".index("c")   | *ValueError* si absence           |
|-------------------+-----------------------------------|
| "aba".count("a")  | nb d'occurences trouvé            |
|-------------------+-----------------------------------|
| "abc"[::-1]       | "cba" *inverse l'ordre*           |




#+begin_src python :session :results output
print(ord(" "))
print(chr(945))
print("abcdef"[::2])
print(min("abc"))
#+end_src

#+RESULTS:
: 32
: α
: ace
: a

** string methods

| "aBcD".capitalize()                  | Abcd                                                         |
| " aBcD".capitalize()                 | aBcD                                                         |
| "123".capitalize()                   | 123                                                          |
| "αβγδ".capitalize()                  | Αβγδ                                                         |
|--------------------------------------+--------------------------------------------------------------|
| "aBcD".swapcase()                    | AbCd                                                         |
|--------------------------------------+--------------------------------------------------------------|
| "hello world".title()                | Hello World -> tous les mots ont une majuscule               |
|--------------------------------------+--------------------------------------------------------------|
| "abc".upper()                        | ABC                                                          |
|--------------------------------------+--------------------------------------------------------------|
| "ABC".lower()                        | abc                                                          |
|--------------------------------------+--------------------------------------------------------------|
| "alpha".center(10)                   | "  alpha   " -> ajoute des espaces et centre                 |
| "alpha".center(2)                    | "alpha"                                                      |
| "alpha".center(10,"#")               | '##alpha###'                                                 |
|--------------------------------------+--------------------------------------------------------------|
| "alpha".startswith("al")             | True                                                         |
|--------------------------------------+--------------------------------------------------------------|
| "alpha".endswith("ha")               | True                                                         |
|--------------------------------------+--------------------------------------------------------------|
| "ab".find("a")                       | index du *premier* élément trouvé                            |
| "ab".find("c")                       | -1                                                           |
| "kappa".find("a", 2)                 | 4 -> trouve "a" à partir de l'index 2 compris                |
| "kappa".find("a", 2, 4)              | -1 -> trouve "a" à partir de l'index 2 jusqu'à 4 non compris |
|--------------------------------------+--------------------------------------------------------------|
| "0123456789".rfind("5")              | 5 -> find from the right                                     |
| "0123456789".rfind("5",4)            | 5 -> dans la portion [4:]                                    |
| "0123456789".rfind("5",6)            | -1 -> pas trouvé                                             |
| "0123456789".rfind("5",4,6)          | 5 -> dans la portion [4:6]                                   |
|--------------------------------------+--------------------------------------------------------------|
| "".isalnum()                         | False -> doit être a-zA-Z0-9                                 |
| "hello world".isalnum()              | False                                                        |
| "ab".isalpha()                       | True -> seulement a-zA-Z                                     |
| "12".isdigit()                       | True -> seulement 0-9                                        |
| "ab".islower()                       | True -> alpha et lowercase                                   |
| "\n".isspace()                       | True -> espace                                               |
| "AB".isupper()                       | True -> alpha et uppercase                                   |
|--------------------------------------+--------------------------------------------------------------|
| ":".join(('ab','c'))                 | ab:c -> marche avec tuple ou liste                           |
|                                      | *TypeError* si autre chose que des str                       |
|--------------------------------------+--------------------------------------------------------------|
| "SiGmA=60".lower()                   | sigma=60                                                     |
|--------------------------------------+--------------------------------------------------------------|
| "\n \t tau ".lstrip()                | "tau " -> left strip                                         |
| "www.cisco.com".lstrip("w.")         | cisco.com -> supprime les w et . devant                      |
| "accent".lstrip("ac")                | ent                                                          |
| " accent".lstrip("ac")               | " accent"                                                    |
|--------------------------------------+--------------------------------------------------------------|
| " tau \n \t".rstrip()                | " tau" -> right strip                                        |
| "cisco.com".rstrip(".com")           | cis                                                          |
|--------------------------------------+--------------------------------------------------------------|
| "\n \t tau \n \t".strip()            | tau                                                          |
|--------------------------------------+--------------------------------------------------------------|
| "azerty".replace("zer", "ppe")       | appety                                                       |
| "azerty".replace("", "-")            | -a-z-e-r-t-y- -> insère entre les lettres                    |
| "This is it!".replace("is", "at", 1) | That is it! -> une seule occurence max                       |
|--------------------------------------+--------------------------------------------------------------|
| "abc def\nghi".split()               | ['abc', 'def', 'ghi']                                        |
|                                      |                                                              |


** find vs index

| find()           | vs | index()              |
|------------------+----+----------------------|
| str only         |    | toutes les sequences |
| -1 si non trouvé |    | *ValueError*         |


** string comparaison

| "alpha" == "alpha"    | True                                  |
| "alpha" < "alphabet"  | True                                  |
| "Beta" < "beta"       | True (compare le premier codepoint B) |
| " " < "0" < "A" < "a" | True                                  |
| "010" < "10"          | True                                  |
| "20" < "8"            | True                                  |
| "10" != 10            | True                                  |
| "10" > 10             | *TypeError*                           |
|                       |                                       |

** transformation
| str(x)      |              |
| int("12")   |           12 |
| int("12.8") | *ValueError* |
| float("12") |         12.0 |
| float("A")  | *ValueError* |
|             |              |


** sorted(x) vs x.sort()
sorted(x) = créé une nouvelle liste triée
x.sort() = la liste est triée in-place


| sorted(["omega", "alpha", "pi", "gamma"]) | ['alpha', 'gamma', 'omega', 'pi'] |
|                                           |                                   |

** exceptions
- 63 builtin exception
- l'ordre des except compte car le premier qui match est choisi

try:
except ZeroDivisionError:        <- le premier qui correspond est choisi
except ArithmeticError:
except (ValueError, IndexError): <- plusieurs exception
except:                          <- en dernier et unique

| ValueError        | paramètre incorrect ex. float('A') |
| ZeroDivisionError |                                    |
| IndexError        | out of range                       |


ex. du plus général au plus spécialisé
BaseException <- Exception <- ArithmeticError <- ZeroDivisionError

** raise et assert

| raise ZeroDivisionError | lève une exception                                   |
| raise                   | dans un except seulement -> relève la même exception |
|-------------------------+------------------------------------------------------|
| assert <expression>     | lève AssertionError si False ou 0                    |
|                         |                                                      |


#+begin_src python :session :results output
def notok(x):
    try:
        return 1/x
    except:
        print("notok except")
        raise

try:
    notok(0)
except ArithmeticError:
    print("ArithmeticError")
#+end_src

#+RESULTS:
: notok except
: ArithmeticError

** quelques exceptions

# abstract builtin exceptions
| exceptions        | parents                                     | exemples                           |
|-------------------+---------------------------------------------+------------------------------------|
| ArithmeticError   | Exception > BaseException                   | 1/0                                | 
| BaseException     |                                             | tout                               |
| LookupError       | Exception > BaseException                   | pb ds collections                  |


# concrete builtin exceptions
| exceptions        | parents                                     | exemples                           |
|-------------------+---------------------------------------------+------------------------------------|
| AssertionError    | Exception > BaseException                   | assert 0                           |
| ImportError       | StandardError > Exception > BaseException   | import incorrect                   |
| IndexError        | LookupError > Exception > BaseException     | [1,2][2]                           |
| KeyboardInterrupt | BaseException                               | Ctrl-c                             |
| KeyError          | LookupError > Exception > BaseException     | { 'a':1, 'b':2 } ['c']             |
| MemoryError       | Exception > BaseException                   | manque de mémoire disponible       |
| OverflowError     | ArithmeticError > Exception > BaseException | nombre trop grand pour être stocké |
|-------------------+---------------------------------------------+------------------------------------|
| AttributeError    |                                             | attribut d'une class inexistant    |


* object oriented programming

MyClass.__name__         = nom de la classe
MyClass.__module__       = module de la classe ex. builtins ou __main__
MyClass.__bases__        = () avec la ou les classes parents    ex. (Parent1, Parent2) car class MyClass(Parent1, Parent2)
MyClass.__subclasses__() = [] avec les classes filles
MyClass.__dict__         = {} avec les var et et méthodes

obj.__dict__ = {} avec var d'instance seulement



def mymethod(self, objet):
objet.method(x)         = à partir d'un objet   = pas besoin de self
MyClass.method(self, x) = à partir d'une classe = besoin du self


| LIFO                             | last in first out                                                                                                   |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| introspection                    | capacité à examiner le type ou les variables d'un objet pendant l'exécution                                         |
| reflection                       | capacité à manipuler les variables et les fonctions d'un objet pendant l'exécution                                  |
| polymorphism                     | capacité à modifier la super-class                                                                                  |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| overriding                       | redéfinir une méthode ou une variable dans une classe fille                                                         |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| méthode abstraite                | pass                                                                                                                |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| for name in obj.__dict__.keys(): | boucle sur les variables de l'objet                                                                                 |
| isinstance(val, int)             | val est il une instance de int ?                                                                                    |
| getattr(obj, name)               | valeur associée à la variable name                                                                                  |
| setattr(obj, name, val)          |                                                                                                                     |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| propriété d'instance             | variable de classe ou variable d'instance                                                                           |
| variable de classe               | définie dans class                                                                                                  |
| self.__var                       | deux underscore -> variable d'instance privée => concept d'encapsulation => AttributeError si on essaie d'y accéder |
| self.var                         | variable d'instance publique                                                                                        |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| __init__(self)                   | constructeur ne peut *pas* retourner de valeur et appelable seulement depuis un constructeur *fils*                 |
| method(self, param)              | méthode avec toujours le premier en tant que self pour représenter l'objet                                          |
| __method(self, param)            | méthode privée avec *name mangling*                                                                                 |
| __str__(self)                    | méthode spéciale permettant d'être print()                                                                          |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| hasattr(objet, 'b')              | b est il une variable d'instance ou de classe ?                                                                     |
| hasattr(MyClass, 'b')            | b est il une variable de classe ?                                                                                   |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| mangled name                     | les variables d'instances privées sont qd même accessible via un nom spécial _Myclass__myhiddenvar                  |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| objet.__dict__                   | dictionnaire avec toutes les variables d'instances (mais pas les variables de classes !!)                           |
| MyClass.__dict__                 | dictionnaire avec var d'instances, var de classes, méthodes publiques et privées                                    |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| méthode                          | toujours au moins un paramètre self                                                                                 |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| type(obj).__name__               | nom de la classe de l'objet                                                                                         |
| MyClass.__name__                 | MyClass                                                                                                             |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| obj.__module__                   | __main__                                                                                                            |
| MyClass.__module__               | __main__                                                                                                            |
| str.__module__                   | builtins                                                                                                            |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
| MyClass.__bases__                | tuples avec les classes parents                                                                                     |
| str.__bases__                    | (<class 'object'>,)                                                                                                 |
|----------------------------------+---------------------------------------------------------------------------------------------------------------------|
|                                  |                                                                                                                     |

#+begin_src python :session :results output
class Stack:
    class_counter = 0
    
    def __init__(self):
        self.__stack_list = []
        Stack.class_counter += 1
        class_counter = 123 # piège ! variable locale

    def push(self, val):
        self.__stack_list.append(val)

    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val

""" héritage """    
class AddingStack(Stack):
    def __init__(self):
        Stack.__init__(self) # à faire seulement dans un constructeur
        self.__sum = 0
        self.nothing = 0

    def push(self, val): # overriding
        self.__sum += val
        Stack.push(self, val) # appel de la méthode parente

    def pop(self): # overriding
        val = Stack.pop(self)
        self.__sum -= val
        return val

    def get_sum(self):
        return self.__sum
    
obj = AddingStack()
obj.push(2)
obj.push(1)
print("sum =", obj.get_sum())
print(obj.pop())
print(obj.pop())

obj.__custom = "hello world" # ajout d'une variable d'instance à la volée
print(obj.__dict__)
print("hack AddingStack __sum", obj._AddingStack__sum)

AddingStack()
print("class counter", Stack.class_counter)

print("AddingStack class __dict__", AddingStack.__dict__)
print(hasattr(obj, "class_counter"))
#+end_src

#+RESULTS:
: sum = 3
: 1
: 2
: {'_Stack__stack_list': [], '_AddingStack__sum': 0, 'nothing': 0, '__custom': 'hello world'}
: hack AddingStack __sum 0
: class counter 2
: AddingStack class __dict__ {'__module__': '__main__', '__init__': <function AddingStack.__init__ at 0x7feed72ea680>, 'push': <function AddingStack.push at 0x7feed72ea710>, 'pop': <function AddingStack.pop at 0x7feed72ea7a0>, 'get_sum': <function AddingStack.get_sum at 0x7feed72ea830>, '__doc__': None}
: True




les noms de variables d'instances privées sont transformées, on peut utiliser ce nom pour y accéder via une astuce
par contre si on défini une variable de classe en dehors de la classe, le nom n'est pas transformé !



#+begin_src python :session :results output
"""
self.var permet de référencer variable de classe ou variable d'instance
""" 
class Daddy:
    def __init__(self):
        print("daddy init")
        
class Classy(Daddy):
    var = 2
    def method(self):
        print(self.var)
        self.other()

    def other(self):
        print("other")

obj = Classy()
obj.method()
print(type(obj).__name__)
#+end_src

#+RESULTS:
: daddy init
: 2
: other
: Classy


#+begin_src python :session :results output
class SuperOne:
    pass

class SuperTwo:
    pass

class Sub(SuperOne, SuperTwo):
    pass

def printBases(cls):
    print('( ', end='')

    for x in cls.__bases__:
        print(x.__name__, end=' ')
    print(')')

printBases(SuperOne)
printBases(SuperTwo)
printBases(Sub)
#+end_src

#+RESULTS:
: ( object )
: ( object )
: ( SuperOne SuperTwo )



#+begin_src python :session :results output
"""
demo introspection
"""
class MyClass:
    pass

obj = MyClass()
obj.a = 1
obj.b = 2
obj.i = 3
obj.ireal = 3.5
obj.integer = 4
obj.z = 5


def incIntsI(obj):
    for name in obj.__dict__.keys(): # on boucle sur les variables
        if name.startswith('i'):
            val = getattr(obj, name) # obtient la valeur associée à la variable
            if isinstance(val, int): # type int ?
                setattr(obj, name, val + 1) 

print(obj.__dict__)
incIntsI(obj)
print(obj.__dict__)
#+end_src

#+RESULTS:
: {'a': 1, 'b': 2, 'i': 3, 'ireal': 3.5, 'integer': 4, 'z': 5}
: {'a': 1, 'b': 2, 'i': 4, 'ireal': 3.5, 'integer': 5, 'z': 5}



#+begin_src python :session :results output
"""
demo __str__(self)
"""
class A:
    def __str__(self):
        return "A"

a = A()
print(str(a) == "A")
#+end_src

#+RESULTS:
: True


#+begin_src python :session :results output
"""
demo constructeur
"""
class A:
    def __init__(self, name):
        print("hello", name)

class B(A):
    pass

b = B("Mickey")
#+end_src

#+RESULTS:
: hello Mickey



** héritage = passer des attributs et méthodes de la super-class à la sous-class



| issubclass(ClassOne, ClassTwo) | True si ClassOne est une sous-class de ClassTwo                 |
| issubclass(ClassOne, ClassOne) | True car *Une classe est une sous-class de lui même*            |
| isinstance(obj, MyClass)       | True si obj est une instance de la class ou super-class MyClass |


#+begin_src python :session :results output
class MyClass:
    def __init__(self, name):
        self.name = name
        
    def __str__(self):
        return "I am " + self.name

class Baby(MyClass):
    def __init__(self):
        MyClass.__init__(self, "Baby")

    
mc = Baby()

print(mc)
print(issubclass(Baby, MyClass))
print(issubclass(Baby, Baby))
print(isinstance(mc, MyClass))
#+end_src

#+RESULTS:
: I am Baby
: True
: True
: True


#+begin_src python :session :results output
class A:
    pass
 
class B(A):
    pass
 
class C(B):
    pass

print(issubclass(C,A))
#+end_src

#+RESULTS:
: True



** opérateur d'égalité = == is

| obj1 = obj2     | fait pointer vers le même objet (ne duplique pas)                                             |
|-----------------+-----------------------------------------------------------------------------------------------|
| obj1 is obj2    | reference equality id(obj1) == id(obj2)                                                       |
| "az" == "a"+"z" | value equality  ex. literal (str, int, float, complex, bool, NoneType, list, tuple, dict, set |
| id(obj)         | id mémoire de l'objet                                                                         |
|                 |                                                                                               |

#+begin_src python :session :results output
class SampleClass:
    def __init__(self, val):
        self.val = val

obj1 = SampleClass(0)
obj2 = obj1
obj2.val += 1
print(obj1.val, obj2.val)
print(obj1 == obj2, obj1 is obj2) # True True
a = "aa"
b = "a" + "a"
c = "a"
c += "a"
print(id(a), id(b), id(c)) # a et b sont les mêmes mais différent de c
print(a is b, a is c) 
print(a == b == c)
#+end_src

#+RESULTS:
: 1 1
: True True
: 140630376396336 140630376396336 140630377910832
: True False
: True

** 2 façons d'appeler le parent 


|              | avec self                     | vs | sans self              |
|--------------+-------------------------------+----+------------------------|
| constructeur | TopClass.__init__(self, name) |    | super().__init__(name) |
|--------------+-------------------------------+----+------------------------|
| méthode      | TopClass.method(self)         |    | super().method()       |




#+begin_src python :session :results output
class MyClass:
    def __init__(self, name):
        self.name = name
        
    def __str__(self):
        return "I am " + self.name

    def method(self):
        print("method")
    
class Baby(MyClass):
    def __init__(self):
        super().__init__("Baby")

    def localmethod(self):
        print("local")
        
    def method(self):
        super().method()
        MyClass.method(self)


        
mc = Baby()
print(mc)
mc.method()
#+end_src

#+RESULTS:
: I am Baby
: method
: method


** héritage multiple : possible mais déconseillé car brise le principe de responsabilité unique,  super() est ambigue, difficile à maintenir

| ordre de priorité pour chercher les variables et méthodes |
|-----------------------------------------------------------|
| dans l'objet                                              |
| dans les super-class du *bas* vers le haut                |
| si héritage multiple : de la *gauche* vers la droite      |

# mnémo
Père(Grand-Père)
Fils(Père)               

vs

Fils(Père, Grand-Père)


#+begin_src python :session :results output
class Left:
    name = "L"

class Right:
    name = "R"

class Son(Left, Right):
    pass

son = Son()
print(son.name)
#+end_src

#+RESULTS:
: L


** pattern "composition" au lieu d'utiliser l'héritage

on peut utiliser la composition au lieu de faire de l'héritage

#+begin_src python :session :results output
class Animal:
    def __init__(self, controller):
        self.controller = controller
    def move(self):
        self.controller.move()

class Dog:
    def move(self):
        print("Dog run")

class Fish:
    def move(self):
        print("Fish swim")

dog = Animal(Dog())
fish = Animal(Fish())
dog.move()
fish.move()
#+end_src

#+RESULTS:
: Dog run
: Fish swim


** MRO - method resolution order

| TypeError: Cannot create a consistent method resolution order (MRO) | on ne peut pas avoir relation père fils dans les 2 sens     |
|                                                                     | utiliser les => pour visualiser les relations et comprendre |
|                                                                     |                                                             |

exemple :
#+begin_src python :session :results output
class A:
    pass

class B(A):  # B => A
    pass

class C(B,A): # C => B => A
    pass

#class D(A,B): # D => A => B     en contradition avec B => A donc TypeError MRO
#    pass

try:
    c = C()
    print("ok")
except Exception as e:
    print("nok "+str(e))
#+end_src

#+RESULTS:
: ok

** héritage multiple, le cas du diamant

#+begin_src python :session :results output
class A:
    pass

class B(A): # B => A
    def me(self):
        print("B")

class C(A): # C => A
    def me(self):
        print("C")

class D(B,C): # D => B => C
    pass

d = D()
d.me() # imprime B car l'ordre d'héritage est D => B => C
#+end_src

#+RESULTS:
: B

** exceptions

| try:                       |                                                    |
| except Exception as e:     | permet de print(e)                                 |
| except:                    |                                                    |
| else:                      | exécuté si pas d'erreur                            |
| finally:                   | toujours exécuté, à placer en dernier              |
|----------------------------+----------------------------------------------------|
| raise Exception            |                                                    |
| raise Exception("trouble") | e.args = ("trouble",)                              |
|----------------------------+----------------------------------------------------|
| e.args                     | (,) tuple avec les paramètres passés à l'exception |
|----------------------------+----------------------------------------------------|
| assert <expression>        | lève AssertionError si False ou 0                  |
|                            | utile pour les tests unitaires                     |



#+begin_src python :session :results output
"""
try catch else finally
"""
def reciprocal(n):
   try:
      n = 1/n
   except ZeroDivisionError:
      print("Division failed")
      return None # effectue quand même finally avant de sortir du try !!
   else:
      print("Everything is fine")
   finally:
      print("Result is ", end="")
      
   return n

print(reciprocal(2))
print(reciprocal(0))
#+end_src

#+RESULTS:
: Everything is fine
: Result is 0.5
: Division failed
: Result is None



#+begin_src python :session :results output
"""
récupérer l'exception
"""
try:
    i = int("hello")
except Exception as e:
    print(e)
#+end_src

#+RESULTS:
: invalid literal for int() with base 10: 'hello'


#+begin_src python :session :results output
"""
imprime toutes les exceptions
"""
def print_exception_tree(thisclass, nest = 0):
    if nest > 1:
        print("   |" * (nest - 1), end="")
    if nest > 0:
        print("   +---", end="")

    print(thisclass.__name__)

    for subclass in thisclass.__subclasses__():
        print_exception_tree(subclass, nest + 1)


print_exception_tree(BaseException)
#+end_src

#+RESULTS:
#+begin_example
BaseException
   +---BaseExceptionGroup
   |   +---ExceptionGroup
   +---Exception
   |   +---ArithmeticError
   |   |   +---FloatingPointError
   |   |   +---OverflowError
   |   |   +---ZeroDivisionError
   |   +---AssertionError
   |   +---AttributeError
   |   +---BufferError
   |   +---EOFError
   |   +---ImportError
   |   |   +---ModuleNotFoundError
   |   |   +---ZipImportError
   |   +---LookupError
   |   |   +---IndexError
   |   |   +---KeyError
   |   |   +---CodecRegistryError
   |   +---MemoryError
   |   +---NameError
   |   |   +---UnboundLocalError
   |   +---OSError
   |   |   +---BlockingIOError
   |   |   +---ChildProcessError
   |   |   +---ConnectionError
   |   |   |   +---BrokenPipeError
   |   |   |   +---ConnectionAbortedError
   |   |   |   +---ConnectionRefusedError
   |   |   |   +---ConnectionResetError
   |   |   +---FileExistsError
   |   |   +---FileNotFoundError
   |   |   +---InterruptedError
   |   |   +---IsADirectoryError
   |   |   +---NotADirectoryError
   |   |   +---PermissionError
   |   |   +---ProcessLookupError
   |   |   +---TimeoutError
   |   |   +---UnsupportedOperation
   |   |   +---itimer_error
   |   +---ReferenceError
   |   +---RuntimeError
   |   |   +---NotImplementedError
   |   |   +---RecursionError
   |   |   +---_DeadlockError
   |   |   +---BrokenBarrierError
   |   +---StopAsyncIteration
   |   +---StopIteration
   |   +---SyntaxError
   |   |   +---IndentationError
   |   |   |   +---TabError
   |   +---SystemError
   |   |   +---CodecRegistryError
   |   +---TypeError
   |   +---ValueError
   |   |   +---UnicodeError
   |   |   |   +---UnicodeDecodeError
   |   |   |   +---UnicodeEncodeError
   |   |   |   +---UnicodeTranslateError
   |   |   +---UnsupportedOperation
   |   +---Warning
   |   |   +---BytesWarning
   |   |   +---DeprecationWarning
   |   |   +---EncodingWarning
   |   |   +---FutureWarning
   |   |   +---ImportWarning
   |   |   +---PendingDeprecationWarning
   |   |   +---ResourceWarning
   |   |   +---RuntimeWarning
   |   |   +---SyntaxWarning
   |   |   +---UnicodeWarning
   |   |   +---UserWarning
   |   +---ExceptionGroup
   |   +---_OptionError
   |   +---error
   |   +---TokenError
   |   +---StopTokenizing
   |   +---ClassFoundException
   |   +---EndOfBlock
   +---GeneratorExit
   +---KeyboardInterrupt
   +---SystemExit
#+end_example



#+begin_src python :session :results output
"""
e.args
"""
try:
    raise Exception
except Exception as e:
    print(e)
    print(e.args)
    
try:
    raise Exception("exception")
except Exception as e:
    print(e)
    print(e.args)

try:
    raise Exception("tuple", "exception")
except Exception as e:
    print(e)
    print(e.args)	
#+end_src

#+RESULTS:
: 
: ()
: exception
: ('exception',)
: ('tuple', 'exception')
: ('tuple', 'exception')



#+begin_src python :session :results output
"""
création d'une exception custom
"""
class MyZeroDivisionError(ZeroDivisionError):	
    pass


def do_the_division(mine):
    if mine:
        raise MyZeroDivisionError("some worse news")
    else:		
        raise ZeroDivisionError("some bad news")


for mode in [False, True]:
    try:
        do_the_division(mode)
    except ZeroDivisionError:
        print('Division by zero')

for mode in [False, True]:
    try:
        do_the_division(mode)
    except MyZeroDivisionError:
        print('My division by zero')
    except ZeroDivisionError:
        print('Original division by zero')
    
#+end_src

#+RESULTS:
: Division by zero
: Division by zero
: Original division by zero
: My division by zero


#+begin_src python :session :results output
"""
si on commente
except PizzaError as pe
alors l'exception PizzaError ne sera pas intercepté

si on commente
except TooMuchCheeseError as tmce
alors toutes les exceptions seront interceptées par except PizzaError
"""
class PizzaError(Exception): 
    def __init__(self, pizza, message):
        Exception.__init__(self, message)
        self.pizza = pizza


class TooMuchCheeseError(PizzaError): # TooMuchCheeseError => PizzaError
    def __init__(self, pizza, cheese, message):
        PizzaError.__init__(self, pizza, message)
        self.cheese = cheese


def make_pizza(pizza, cheese):
    if pizza not in ['margherita', 'capricciosa', 'calzone']:
        raise PizzaError(pizza, "no such pizza on the menu")
    if cheese > 100:
        raise TooMuchCheeseError(pizza, cheese, "too much cheese")
    print("Pizza ready!")

for (pz, ch) in [('calzone', 0), ('margherita', 110), ('mafia', 20)]:
    try:
        make_pizza(pz, ch)
    except TooMuchCheeseError as tmce:
        print(tmce, ':', tmce.cheese)
    except PizzaError as pe: # catch toutes les erreurs même les filles
        print(pe, ':', pe.pizza)
        
#+end_src

#+RESULTS:
: Pizza ready!
: too much cheese : 110


#+begin_src python :session :results output
try:
  print(__name__)
  assert __name__ == "__main__"
except:
  print("fail", end=' ')
else:
  print("success", end=' ')
finally:
  print("done")
#+end_src

#+RESULTS:
: __main__
: success done


#+begin_src python :session :results output
"""
print(e) imprime le contenu dans e.args
"""
class Ex(Exception):
    def __init__(self, msg):
        Exception.__init__(self, msg + msg)
        print(self.args)
        self.args = (msg,)
 
 
try:
    raise Ex('ex')
except Ex as e:
    print(e) # imprime le contenu de self.args
except Exception as e:
    print(e)
#+end_src

#+RESULTS:
: ('exex',)
: ex



* generators, iterators et closures

| iterator               | objet d'une classe contenant les méthodes *__iter__()* et *__next__()*, et doit *raise StopIteration* quand on arrive à la fin |
| generator              | 1- fonction retournant *yield*                                                                                                 |
|                        | 2- (x ** 2 for x in range(5))   noter les () -> les valeurs sont déterminées au fur et à mesure de l'itération                 |
|                        | 3- map(fn,lst)                                                                                                                 |
|                        | 4- filter(fn,lst)                                                                                                              |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------|
| conditional expression | True if 0 >= 0 else False                                                                                                      |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------|
| list comprehension     | [x ** 2 for x in range(5)]   noter les [] -> la liste est générée de suite                                                     |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------|
| lambda function        | fonctions anonymes                                                                                                             |
|                        | lambda : 1                                                                                                                     |
|                        | lambda x: x ** 0.5                                                                                                             |
|                        | lambda x,y: x **y                                                                                                              |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------|
| map(fn, lst)           | retourne un generator avec toutes les valeurs de fn(x) avec en entrée les valeurs de lst                                       |
|                        | map(lambda x: x.title(), ["hello", "world"])                                                                                   |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------|
| filter(fn, lst)        | retourne un generator avec les valeurs de lst filtrées selon fn(x) qui retourne un bool                                        |
|                        | filter(lambda s: isinstance(s, str), [1, "hello", 0, "world"])                                                                 |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------|
| closure                | fonction retournant une fonction, cette dernière gardant une copie de l'environnement et des variables                         |
|                        | def outer(x):                                                                                                                  |
|                        | ..def inner(y):                                                                                                                |
|                        | ....return y**x                                                                                                                |
|                        | ..return inner                                                                                                                 |
|------------------------+--------------------------------------------------------------------------------------------------------------------------------|
|                        |                                                                                                                                |



** iterateurs = retourne une série de valeur

- implémenter __iter__() : retourne l'iterateur, ex. self
- implémenter __next__()
- utiliser raise StopIteration pour arrêter l'itérateur


#+begin_src python :session :results output
class I:
    def __init__(self):
        self.s = 'abc'
        self.i = 0
 
    def __iter__(self):
        return self
 
    def __next__(self):
        if self.i == len(self.s):
            raise StopIteration
        v = self.s[self.i]
        self.i += 1
        return v
 
 
for x in I():
    print(x,end='')
#+end_src

#+RESULTS:
: abc


#+begin_src python :session :results output
mylist = [1,2]
myiter = iter(mylist)
try:
    print(next(myiter))
    print(next(myiter))
    print(next(myiter))
except Exception:
    print("can't iter more")
#+end_src

#+RESULTS:
: 1
: 2
: can't iter more


#+begin_src python :session :results output
class Fib:
    def __init__(self, nn):
        self.__n = nn
        self.__i = 0
        self.__p1 = self.__p2 = 1

    def __iter__(self):
        print("Fib iter")
        return self

    def __next__(self):
        self.__i += 1
        if self.__i > self.__n:
            raise StopIteration
        if self.__i in [1, 2]:
            return 1
        ret = self.__p1 + self.__p2
        self.__p1, self.__p2 = self.__p2, ret
        return ret

class Class:
    def __init__(self, n):
        self.__iter = Fib(n)

    def __iter__(self):
        print("Class iter")
        return self.__iter


object = Class(10)
print(list(object))
#+end_src

#+RESULTS:
: Class iter
: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

** generator = utiliser yield = stock la série pour la retourner à la fin


#+begin_src python :session :results output
"""
usage de yield
"""
def funA(n):
    for i in range(n):
        return i

def funB(n):
    for i in range(n):
        yield i
    yield "end"

print(funA(5))
print(funB(5))
print(list(funB(5)))

#+end_src

#+RESULTS:
: 0
: <generator object funB at 0x7fe70fa07ed0>
: [0, 1, 2, 3, 4, 'end']



#+begin_src python :session :results output
"""
usage de list comprehension avec generator
"""
def powers_of_2(n):
    power = 1
    for i in range(n):
        yield power
        power *= 2

t = [x for x in powers_of_2(5)]
l = list(powers_of_2(5))

print(t)
print(l)
#+end_src

#+RESULTS:
: [1, 2, 4, 8, 16]
: [1, 2, 4, 8, 16]


#+begin_src python :session :results output
"""
usage de in avec generator
"""
def powers_of_2(n):
    power = 1
    for i in range(n):
        yield power
        power *= 2

for i in range(20):
    if i in powers_of_2(4):
        print(i)
#+end_src

#+RESULTS:
: 1
: 2
: 4
: 8

#+begin_src python :session :results output
"""
fibonacci generator
"""

def fibonacci(n):
    p = pp = 1
    for i in range(n):
        if i in [0, 1]:
            yield 1
        else:
            n = p + pp
            pp, p = p, n
            yield n
 
fibs = list(fibonacci(10))
print(fibs)
#+end_src

#+RESULTS:
: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


** [expr1] if [condition] else [expr2]

#+begin_src python :session :results output
"""
utilisation de l'opérateur [expr1] if [condition] else [expr2]
"""
list1 = []
for x in range(10):
    list1.append(1 if x % 2 == 0 else 0)
print(list1)

print([1 if x % 2 == 0 else 0 for x in range(10)])
#+end_src

#+RESULTS:
: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]


** List comprehensions [] vs generators ()

pour créer :
- list comprehensions utiliser [] ou {}  = la liste est créée
- generator utiliser ()                  = les valeurs sont calculées au fur et à mesure

  
#+begin_src python :session :results output
list_comp = [1 if x % 2 == 0 else 0 for x in range(10)]
dict_comp = { chr(x):0 for x in range(ord('a'), ord('z')+1) }
generator = (1 if x % 2 == 0 else 0 for x in range(10))

print(list_comp)
print(dict_comp)
print(generator)

print(list(generator))
print(list(generator)) # la seconde fois c'est []
#+end_src

#+RESULTS:
: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
: {'a': 0, 'b': 0, 'c': 0, 'd': 0, 'e': 0, 'f': 0, 'g': 0, 'h': 0, 'i': 0, 'j': 0, 'k': 0, 'l': 0, 'm': 0, 'n': 0, 'o': 0, 'p': 0, 'q': 0, 'r': 0, 's': 0, 't': 0, 'u': 0, 'v': 0, 'w': 0, 'x': 0, 'y': 0, 'z': 0}
: <generator object <genexpr> at 0x7fe70fa164d0>
: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
: []


** lambda <parametres>:<expression> = fonction anonyme

utilité = évite de définir une fonction qui ne sera utilisée qu'une fois

#+begin_src python :session :results output
two = lambda: 2                 # sans paramètre
sqr = lambda x: x*x             # un paramètre
pwr = lambda x,y: x**y          # plusieurs paramètres

print(two())
print(sqr(2))
print(pwr(2,3))
#+end_src

#+RESULTS:
: 2
: 4
: 8


#+begin_src python :session :results output
def print_function(args, fun):
    for x in args:
        print('f(', x,')=', fun(x), sep='')


def poly(x):
    return 2 * x**2 - 4 * x + 2


print_function([x for x in range(1, 3)], poly)
print_function([x for x in range(3, 5)], lambda x: 2 * x**2 - 4 * x + 2) # évite de définir poly
#+end_src

#+RESULTS:
: f(1)=0
: f(2)=2
: f(3)=8
: f(4)=18


#+begin_src python :session :results output
"""
deux possibilités d'assigner un nom à un lambda
"""
def f1(x): return 2*x  # façon recommandée par PEP8
f2 = lambda x: 2*x

print(f1(1))
print(f2(2))
#+end_src

#+RESULTS:
: 2
: 4




** lambda et map()

map(fn,x) retourne un generator avec le résultat de fn sur chaque élément de x

- map(function, list)
- map(function, tuple)
- map(function, generator)
 
#+begin_src python :session :results output
m = map(lambda x: x*x, [x for x in range(5)])
print(m)
print(list(m))
#+end_src

#+RESULTS:
: <map object at 0x7fe70fa0c640>
: [0, 1, 4, 9, 16]

#+begin_src python :session :results output
"""
set the least significant bit
en applicant |1 on s'assure que le dernier bit est 1

001  | 001  = 001 = 1
010  | 001  = 011 = 3
011  | 001  = 011 = 3
100  | 001  = 101 = 5
101  | 001  = 101 = 5

rappel des valeurs décimales des bits
|128|64|32|16|8|4|2|1

rappel :
quand on fait ~1, ne pas oublier que le premier bit représente le signe
~01 = 10 = -2
"""
print(list(map(lambda x: x|1, [1,2,3,4,5])))
#+end_src

#+RESULTS:
: [1, 3, 3, 5, 5]



** lambda et filter()

filter(fn,x)
- fonctionne comme map(fn,x) avec fn qui retourne un bool
- retourne un generator avec les résultats qui ont retourné True

#+begin_src python :session :results output
from random import seed, randint
seed()
data = [randint(-10,10) for x in range(10)]
filtered = filter(lambda x: x>0 and x%2==0, data)
print(data)
print(list(filtered))
#+end_src

#+RESULTS:
: [-7, 10, -9, 8, -4, -10, 9, -3, 4, 1]
: [10, 8, 4]

** closure

- fonction retournant une fonction
- la fonction retournée contient l'état de toutes les variables locales

#+begin_src python :session :results output
"""
closure sans paramètre
"""
def outer(par):
    loc = par
    def inner():
        return loc
    return inner # inner est un closure

fun = outer(1)
print(fun)    # sans les () = la fonction
print(fun())  # avec les () = le résultat de la fonction
#+end_src

#+RESULTS:
: <function outer.<locals>.inner at 0x7fe70fa40180>
: 1


#+begin_src python :session :results output
"""
closure avec paramètre
"""
def outer(par):
    loc = par
    def power(x):
        return x ** loc
    return power

fsqr = outer(2) # retourne power
fcub = outer(3)

print(fsqr(5)) # invoque power(5) avec loc=2
print(fcub(5)) # invoque power(5) avec loc=3
#+end_src

#+RESULTS:
: 25
: 125


#+begin_src python :session :results output
"""
autre exemple de closure
"""
def tag(tg):
    tg2 = tg
    tg2 = tg[0] + '/' + tg[1:]
 
    def inner(str):
        return tg + str + tg2
    return inner
 
 
b_tag = tag('<b>')
print(b_tag('Monty Python'))
#+end_src

#+RESULTS:
: <b>Monty Python</b>


* files (streams, processing, diagnosing stream problems)

sous windows, name = "/dir/file"
python va savoir que c'est "c:/dir/file"

3 open modes sur les streams :
- read
- write
- update (read et write)

text stream = consommé caractère par caractère ou ligne par ligne
binary stream = consommé byte par byte ou block par block

en python les fin de lignes sont adaptées automatiquement selon l'os
fin de ligne linux   = \n coresspond à LF (ASCII code 10)
fin de ligne windows = \r\n correspond à CR LF (ASCII code 13 et 10)
                               
classe BufferedIOBase = peut traiter n'importe quel fichier
classe TextIOBase     = peut traiter les fichiers textes



*bytearray*
liste de int 0-255 inclus
ba = bytearray(10) # initialisé à 0
TypeError  si non int
ValueError si en dehors de 0-255

ex.
ba = bytearray(b'abcdef') # on converti b'abcdef' en bytearray
len(ba) -> 6
ba[0]   -> 97
ba[5]   -> 102


ex.
b = bytearray(3)
print(b)  -> bytearray(b'\x00\x00\x00')




*lecture de fichier texte*
src = open("..", "rt")
- src.read(n)      = ".."        lit n bytes, retourne '' si plus rien
- src.readline()   = ".."        lit une ligne
- src.readlines(n) = ["..",".."] lit n bytes , retourne [] si plus rien

*écriture de fichier texte*
dst = open("..", "wt")
dst.write("..")

*lecture de fichier binaire*
src = open("..", "rb")
- méthode 1
ba = bytearray(10)
src.readinto(ba) = retourne le nb de bytes mis dans ba, retourne 0 si plus rien   
- méthode 2
ba = bytearray(src.read()) # lit tout le fichier et transforme en bytearray 

*écriture de fichier binaire*
src = open("..", "wb")
ba = bytearray(5)
src.write(ba)


Itération d'un objet open
- ligne par ligne
- close() automatique

for line in open("..", "rt"):
    print(line, end="")



| open(..)                                                        | retourne un objet iterable                             |
|-----------------------------------------------------------------+--------------------------------------------------------|
| with open(/path/to/file/) as myfile:                            | mode 'r' = read (default)                              |
| content = myfile.read()                                         |                                                        |
|-----------------------------------------------------------------+--------------------------------------------------------|
| with open(/path/to/file/, mode='a', encoding = None) as myfile: |                                                        |
| myfile.write("\nhello world")                                   |                                                        |
|-----------------------------------------------------------------+--------------------------------------------------------|
| with open("img.bmp", mode='r+b') as myfile:                     | overwrite/read et binary                               |
|-----------------------------------------------------------------+--------------------------------------------------------|
| mode 'r'                                                        | read only (défaut)   = FileNotFoundError si existe pas |
| mode 'a'                                                        | append (à la fin)                                      |
| mode 'w'                                                        | new file puis write                                    |
| mode 'r+'                                                       | overwrite / read     = FileNotFoundError si existe pas |
| mode 'w+'                                                       | new file puis write / read                             |
| mode 'x'                                                        | exclusive creation   = Exception si existe déjà        |
|-----------------------------------------------------------------+--------------------------------------------------------|
| mode 'rb' 'ab' 'wb' 'r+b' 'w+b'                                 | binary file                                            |
| mode 'rt' 'at' 'wt' 'r+t' 'w+t'                                 | text file (défault)                                    |


3 streams ouverts par défaut =
sys.stdin
sys.stdout
sys.stderr

#+begin_src python :session :results output
import sys
sys.stderr.write("Error message")
#+end_src

#+RESULTS:
: Error message



#+begin_src python :session :results output
try:
    stream = open("/etc/dummy", "rt")
    stream.close() # IOError en cas de pb
except Exception as e:
    print("Cannot open file", e)
#+end_src

#+RESULTS:
: Cannot open file [Errno 2] No such file or directory: '/etc/dummy'


** module errno 
| errno.EACCES | permission denied                                                             |
| errno.EBADF  | bad descriptor file        ex. stream non ouvert              |
| errno.EEXIST | fils exists                ex. renommer avec son nom précédent                |
| errno.EFBIG  | file too large                                                                |
| errno.EISDIR | is a directory             ex. manip un fichier alors que c'est un répertoire |
| errno.EMFILE | too many open files                                                           |
| errno.ENOENT | no entry = no such file or directory                                          |
| errno.ENOSPC | no space left on device                                                       |

#+begin_src python :session :results output
"""
exemple d'utilisation de errno pour diagnostiquer en détail un problème
"""
import errno
try:
    s = open("/etc/dummy", "rt")
    s.close()
except Exception as e:
    if e.errno == errno.ENOENT:
        print("the file does not exist")
    elif e.errno == errno.EMFILE:
        print("too many open files")
    else:
        print("the error number is:", e.errno)
#+end_src

#+RESULTS:
: the file does not exist


** os.strerror(e.errno) = convertir e.errno en message compréhensible

#+begin_src python :session :results output
from os import strerror
try:
    s = open("/etc/dummy", "rt")
    s.close()
except Exception as e:
    print("cannot open file:", strerror(e.errno))
#+end_src

#+RESULTS:
: cannot open file: No such file or directory


** s = open(..) puis s.read(n) s.read() s.readline() s.readlines() s.readlines(max bytes)

#+begin_src python :session :results output
from os import strerror
try:
    s1 = open('/etc/redhat-release', "rt")
    print(s1.read(1))
    s1.close()
    
    s2= open('/etc/redhat-release', "rt")
    print(s2.read().strip())
    s2.close()
    
    s3= open('/etc/npmrc', "rt")
    print(s3.readline().strip())
    s3.close()
    
    s4= open('/etc/hosts', "rt")
    lines = s4.readlines()
    print(len(lines))
    s4.close()
    
    s5= open('/etc/hosts', "rt")
    print(len(s5.readlines(200)), len(s5.readlines(200)))
    s5.close()
    
except IOError as e:
    print("I/O error occurred: ", strerror(e.errno)) 
#+end_src

#+RESULTS:
: F
: Fedora release 37 (Thirty Seven)
: prefix=/usr/local
: 5
: 3 2


#+begin_src python :session :results output
"""
exemple
lecture caractère par caractère = non adapté à un gros fichier
"""
from os import strerror

try:
    counter = 0
    stream = open('/etc/npmrc', "rt")
    char = stream.read(1)
    while char != '':
        print(char, end='')
        counter += 1
        char = stream.read(1)
    stream.close()
    print("-> Characters in file:", counter)
except IOError as e:
    print("I/O error occurred: ", strerror(e.errno))
#+end_src

#+RESULTS:
: prefix=/usr/local
: python=/usr/bin/python3
: -> Characters in file: 42


#+begin_src python :session :results output
"""
iteration sur l'objet retourné par open()
"""
from os import strerror

try:
    counter = 0
    line_counter = 0
    for line in open('/etc/npmrc', "rt"):
        line_counter += 1
        for ch in line:
            counter += 1

    print("-> Lines in file:", line_counter)        
    print("-> Characters in file:", counter)
except IOError as e:
    print("I/O error occurred: ", strerror(e.errno))
#+end_src

#+RESULTS:
: -> Lines in file: 2
: -> Characters in file: 42


** write file

#+begin_src python :session :results output
from os import strerror

try:
    file = open('/tmp/test-file.txt', 'wt') # A new file is created.
    for i in range(3):
        file.write("line #" + str(i+1) + "\n")
    file.close()

    print(list(open('/tmp/test-file.txt', 'rt')))
except IOError as e:
    print("I/O error occurred: ", strerror(e.errno))
#+end_src

#+RESULTS:
: ['line #1\n', 'line #2\n', 'line #3\n']


** bytearray(n) : comme une list [] mais avec des integer 0-255 inclus

utilité = ex. lire une image bmp

création d'un array avec des zeros
data = bytearray(10) 

TypeError  = si un élément n'est pas un int
ValueError = si un élément n'est pas dans 0-255 inclus


| file.write(data)       | écriture d'un bytearray dans un fichier                              |
|------------------------+----------------------------------------------------------------------|
| file.readinto(data)    | remplissage d'un bytearray à partir d'un fichier                     |
| bytearray(file.read()) | converti un bytes en bytearray                                       |
|                        | pour éviter les pbs de saturation mémoire lire par bloc file.read(n) |
|                        |                                                                      |


#+begin_src python :session :results output
file = open("/tmp/test-file.bin", "rb")
print(type(file.read()).__name__) # file.read() retourne un bytes immutable
file.close()

file = open("/tmp/test-file.bin", "r")
print(type(file.read()).__name__) # file.read() retourne un str
file.close()
#+end_src

#+RESULTS:
: bytes
: str



#+begin_src python :session :results output
from os import strerror

data = bytearray(5)

for i in range(len(data)):
    data[i] = i

print([hex(x) for x in data])
    
try: 
    # écriture d'un bytearray dans un fichier
    bf = open("/tmp/test-file.bin", "wb") # binary flag
    nb = bf.write(data) # retourne le nb de bytes écrit
    print(nb, "bytes wrote")
    bf.close()

    # remplissage d'un bytearray à taille fixe à partir d'un fichier
    data = bytearray(10)
    bf = open("/tmp/test-file.bin", "rb") # binary flag
    bf.readinto(data)
    print([hex(x) for x in data])

    # lecture par bloc de 2
    bf.seek(0)
    print("bloc 1", [hex(x) for x in bytearray(bf.read(2))])
    print("bloc 2",[hex(x) for x in bytearray(bf.read(2))])
    print("bloc 3",[hex(x) for x in bytearray(bf.read(2))])
    print("bloc 4",[hex(x) for x in bytearray(bf.read(2))])
    bf.close()
except Exception as e:
    print(strerror(e.errno))
    
#+end_src

#+RESULTS:
: ['0x0', '0x1', '0x2', '0x3', '0x4']
: 5 bytes wrote
: ['0x0', '0x1', '0x2', '0x3', '0x4', '0x0', '0x0', '0x0', '0x0', '0x0']
: bloc 1 ['0x0', '0x1']
: bloc 2 ['0x2', '0x3']
: bloc 3 ['0x4']
: bloc 4 []


** copie de fichier

#+begin_src python :session :results output
from os import strerror
src = open("/tmp/test-file.bin", "rb")
dst = open("/tmp/test-file-copy.bin", "wb")
buffer = bytearray(65536)
total = 0
try:
    readin = src.readinto(buffer)
    while readin > 0:
        written = dst.write(buffer[:readin])
        total += written
        readin = src.readinto(buffer)
except IOError as e:
    print("Cannot create file: ", strerror(e.errno))
    exit(e.errno) # retourne errno comme code erreur
print(total, "bytes written")
src.close()
dst.close()
#+end_src

#+RESULTS:
: 5 bytes written


** fonction sorted() et méthode sort()

- sorted(iterable)
- sorted(iterable, key=, reverse=) key est une fonction pour identifier l'élément servant de clef au tri et reverse est un bool

- mylist.sort()
- mylist.sort(key=, reverse=)


#+begin_src python :session :results output
lst = "this is a test string".split()
tpl = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
dic = {'a':2, 'b':3, 'c':1}
print(sorted(lst)) # tri simple
print(sorted(tpl, key=lambda x: x[2])) # tri sur la note nombre
print(sorted(dic, key=lambda x: dic[x], reverse=True)) # renvoi une liste de clef en faisant un tri descendant sur les valeurs

lst2 = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
lst2.sort(key=lambda x: x[2], reverse=True) # tri sur la note lettre
print(lst2)
#+end_src

#+RESULTS:
: ['a', 'is', 'string', 'test', 'this']
: [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
: ['b', 'a', 'c']
: [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]



* module os

os.uname().sysname     Linux                                                   os  
os.uname().nodename    ci640                                                   hostname
os.uname().release     6.1.18-100.fc36.x86_64                                  os release
os.uname().version     #1 SMP PREEMPT_DYNAMIC Sat Mar 11 16:46:48 UTC 2023     os version
os.uname().machine     x86_64                                                  identifiant hardware


os.name
- posix   si unix linux
- nt      si windows
- java    si jython


os.mkdir("relative")
os.mkdir("/absolute/path")   mkdir
os.makedirs("some/path")     mkdir -p
FileExistsError              si le répertoire existe

os.listdir()                 liste les fichiers et répertoires du répertoire courant sans "." et ".."
os.listdir("some/path")

os.chdir("some/path")        cd
os.getcwd()                  pwd

os.rmdir("some/path")        rm
os.removedirs("some/path")   rm -r

os.system("some command")    retourne l'exit code


*linux*
| import os  |                       |
|------------+-----------------------|
| os.uname() | équivalent à uname -a |
| os.name    | posix                 |
|            |                       |


*répertoire*
| os.mkdir("..")     |                           |                                                   |
| os.makedirs("x/y"  | mkdir -p                  |                                                   |
| os.chdir("..")     | cd                        |                                                   |
| os.getcwd()        | pwd                       |                                                   |
| os.listdir()       | [..]                      | liste le contenu du répertoire                    |
| os.rmdir("..")     | rm                        | attention le répertoire doit être vide et exister |
| os.removedirs("..) | rm -r                     | attention le répertoire doit être vide et exister                                                  |
| FileExistsError    | si répertoire existe déjà |                                                   |

*custom*
| os.system("..") | commande que l'on veut; retourne exit code |
|                 |                                            |



#+begin_src python :session :results output
import os
print(os.uname())
exitcode = os.system("pwd")
#+end_src

#+RESULTS:
: posix.uname_result(sysname='Linux', nodename='ci640', release='6.1.18-100.fc36.x86_64', version='#1 SMP PREEMPT_DYNAMIC Sat Mar 11 16:46:48 UTC 2023', machine='x86_64')
: /home/thai/checkout/python/formation


* module datetime

*date*
from datetime import date
d = date.today()
d.day    -> readonly
d.month  -> readonly
d.year   -> readonly

*custom date*
a) manuellement
noel = date(2023,12,25)

avec
1 <= year <= 9999
1 <= month <= 12
1 <= day <= dépend du mois
sinon ValueError

b) à partir d'un timestamp
date.fromtimestamp(1679930464.6341553)

c) à partir d'un format iso 8601 YYY-MM-DD
date.fromisoformat("2023-03-27")


*modifier une date*
d = date.today()
d = d.replace(year=1992, month=1, day=16)

*jour de la semaine*
d.weekday()
0 = lundi   1=mardi  2=mercredi  3=jeudi   4=vendredi  5=samedi   6=dimanche

d.isoweekday()
1 = lundi   2=mardi  3=mercredi  4=jeudi   5=vendredi  6=samedi   7=dimanche  (spec iso 85601)


*horaire*
from datetime import time
t = time(14, 53, 20, 1)    # 14:53:20.000001
t.hour
t.minute
t.second
t.microsecond

*date et heure*
datetime(year, month, day, hour, minute, second, microsecond, tzinfo, fold)

from datetime import datetime
datetime(2019, 11, 4, 14, 53, 0, 0)              # print => 2019-11-04 14:53:00
datetime(2019, 11, 4, 14, 53, 0, 0).date()       # print => 2019-11-04
datetime(2019, 11, 4, 14, 53, 0, 0).time()       # print => 14:53:00

datetime.today()    # date et heure locales avec tzinfo=None
datetime.now()      # date et heure locales avec tzinfo paramétrable 
datetime.utcnow()   # date et heure utc     avec tzinfo=None

*timestamp*
float du nb de sec écoulées depuis le 01/01/1970

from datetime import datetime

datetime(2020, 10, 4, 14, 55).timestamp()         # 1601816100.0

*formatage*
toutes les classes du module datetime ont une méthode strftime(x)
https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes

from datetime import date
from datetime import time
from datetime import datetime

date(2020, 1, 4).strftime('%Y/%m/%d')                           # 2020/01/04
time(14, 53).strftime("%H:%M:%S")                               # 14:53:00
datetime(2020, 11, 4, 14, 53).strftime("%y/%B/%d %H:%M:%S")     # 20/November/04 14:53:00

datetime.strptime("2019/11/04 14:53:00", "%Y/%m/%d %H:%M:%S"))  # 2019-11-04 14:53:00  -> reformate un str en str

%Y – returns the year with the century as a decimal number;
%m – returns the month as a zero-padded decimal number;
%d – returns the day as a zero-padded decimal number;
%H – returns the hour as a zero-padded decimal number;
%M – returns the minute as a zero-padded decimal number;
%S – returns the second as a zero-padded decimal number.


majuscule = full
%y 23
%Y 2023

%b Mar
%B March



*durée*
la différence créé un objet timedelta

from datetime import date
from datetime import datetime

date(2020, 11, 4) - date(2019, 11, 4)                                # datetime.timedelta(days=366)
datetime(2020, 11, 4, 0, 0, 0) - datetime(2019, 11, 4, 14, 53, 0)    # datetime.timedelta(days=365, seconds=32820)

*timedelta*
from datetime import timedelta
t = timedelta(weeks=2, days=2, hours=3)            # print "16 days, 3:00:00"
t.days             # 16
t.seconds          # 10800
t.microseconds     # 0


#+begin_src python :session :results output
"""
ajout de durée grâce à timedelta
on peut multiplier un timedelta
on peut ajouter ou soustraire à un objet date/datetime (mais pas time)
"""
from datetime import timedelta
from datetime import date
from datetime import datetime

delta = timedelta(weeks=2, days=2, hours=2)
delta *= 2 
print(delta)

print(date(2019, 10, 4) + delta)
print(datetime(2019, 10, 4, 14, 53) + delta)
#+end_src

#+RESULTS:
: 32 days, 4:00:00
: 2019-11-05
: 2019-11-05 18:53:00


* module time

*timestamp*
import time
timestamp = time.time()  # ex. 1679930464.6341553

*sleep*
time.sleep(n)            # pause de n seconds

*unix epoch*
correspond au nb de seconds depuis le 01/01/1970

time.ctime(1572879180)                          # converti unix epoch en str, ici      "Mon Nov  4 15:53:00 2019"
time.ctime()                                    # sans argument donne l'heure courante "Mon Mar 27 19:15:55 2023"


t = time.gmtime(1572879180)     # temps UTC    via un objet time.struct_time
t = time.localtime(1572879180)  # temps local  via un objet time.struct_time

time.mktime(2019, 11, 4, 14, 53, 0, 0, 308, 0)  # créé un unix epoch, ici 1572879180.0
time.mktime(t)                                  # créé un unix epoch, ici 1572879180.0


time.asctime(t)                 # converti struct_time en str, ici     "Mon Nov  4 14:53:00 2019"



t.tm_year     -> année
t.tm_mon      -> mois 1-12
t.tm_mday     -> jour 1-31
t.tm_hour     
t.tm_min
t.tm_sec
t.tm_wday     -> weekday  0-6
t.tm_yday     -> year day 1-366
t.tm_isdst    -> heure d'été 1:yes 0:no -1:inconnu
t.tm_zone     -> timezone
t.tm_gmtoff   -> offset east of utc en secondes


*formatage*
https://docs.python.org/3/library/time.html#time.strftime

import time
time.strftime("%Y/%m/%d %H:%M:%S")                              # 2023/03/28 11:51:43 (date heure courante)
time.strftime("%Y/%m/%d %H:%M:%S", time.gmtime(1572879180))     # formatage d'un time.struct_time

time.strptime("2019/11/04 14:53:00", "%Y/%m/%d %H:%M:%S")       # créé un objet time.struct_time


* synthèse heures et dates

classes utiles du module datetime :
- datetime.date(y,m,d)  attributs day month year
  datetime.date.today()
  datetime.date.fromtimestamp(x)
  
- datetime.time(h,m,s,ms)

- datetime.datetime(y,m,d,h,m,s,ms)


méthode strftime("%Y/%m/%d %H:%M:%S") sur les classes date, time, datetime
addition et soustraction possible sur objets date et datetime = résultat objet timedelta  


module time :
- time.time()    = timestamp
- time.sleep(s)  = pause de s seconds



* module calendar

https://docs.python.org/3/library/calendar.html


*afficher calendrier*

paramètres
w - date column width (default 2)
l - number of lines per week (default 1)
c - number of spaces between month columns (default 6)
m - number of columns (default 3)


import calendar

calendar.calendar(2023)             # str avec le calendrier de l'année      # paramètres w l c m
calendar.prcal(2023)                # print le calendrier de l'année

calendar.month(2023, 3)             # str avec seulement le mois de mars     # paramètres w l
calendar.prmonth(2023, 3)           # print


*changement du premier jour de la semaine*
import calendar
calendar.setfirstweekday(calendar.SUNDAY)         # au lieu de calendar.MONDAY par défaut


*jour de la semaine*
import calendar
calendar.weekday(2023, 12, 25)                    # 0 = lundi

Monday	        0	calendar.MONDAY
Tuesday	        1	calendar.TUESDAY
Wednesday	2	calendar.WEDNESDAY
Thursday	3	calendar.THURSDAY
Friday	        4	calendar.FRIDAY
Saturday	5	calendar.SATURDAY
Sunday	        6	calendar.SUNDAY


calendar.weekheader(2)                            # sur 2 caractères : Mo Tu We Th Fr Sa Su
calendar.weekheader(1)                            # M T W T F S S
calendar.weekheader(3)                            # Mon Tue Wed Thu Fri Sat Sun


*année bisextile*
calendar.isleap(2023)                             # False
calendar.leapdays(2010, 2023)                     # 3 = nb d'année bisextile entre 2010 et 2022 (2023 non inclus)


*calendar.Calendar*
c = calendar.Calendar(n)  # avec un C majuscule et n (facultatif) représente le premier jour de la semaine

ensuite on peut utiliser les itérateurs :
c.iterweekdays()                  # jours de la semaine ex. 0 1 2 3 4 5 6 
c.itermonthdates(2019, 11)        # liste de date complète ex. 2019-10-28 2019-10-29 .. 2019-11-30 2019-12-01
c.itermonthdays(2019, 11)         # les jours du mois avec 0=jour non comptabilisé car mois limitrophe pour faire des semaines complètes
c.monthdays2calendar(2020, 12)    # calendrier du mois en tuple (jour, num jour) ex. (31, 3) qui est jeudi 31




#+begin_src python :session :results output
import calendar  
c = calendar.Calendar(calendar.MONDAY) # en paramètre, le premier jour de la semaine
c2 = calendar.Calendar()               # par défaut le premier jour de la semaine est lundi

# itère sur la liste des jours de la semaine
for weekday in c.iterweekdays():
    print(weekday, end=" ")

print()    

# itère sur les jours du mois en dépassant sur les mois d'à côté pour avoir des semaines complètes
for date in c.itermonthdates(2019, 11): # en paramètre, année et mois
    print(date, end=" ")

print()

# itère sur les jour du mois, avec 0 = les jours dépassant pour faire une semaine complète
for iter in c.itermonthdays(2019, 11): # en paramètre, année et mois
    print(iter, end=" ")

print()

# itère sur chaque semaine, chaque jour de la semaine est représenté par (day number, weekday number)
# ex. (0,4) : 0 = jour dépassant pour faire semaine complète, 4 correspond à calendar.FRIDAY
# ex. (31,3) : 31 = le 31 du mois de déc 2020, 3 correspond à calendar.THURSDAY
for data in c.monthdays2calendar(2020, 12):
    print(data)    
#+end_src

#+RESULTS:
: 0 1 2 3 4 5 6 
: 2019-10-28 2019-10-29 2019-10-30 2019-10-31 2019-11-01 2019-11-02 2019-11-03 2019-11-04 2019-11-05 2019-11-06 2019-11-07 2019-11-08 2019-11-09 2019-11-10 2019-11-11 2019-11-12 2019-11-13 2019-11-14 2019-11-15 2019-11-16 2019-11-17 2019-11-18 2019-11-19 2019-11-20 2019-11-21 2019-11-22 2019-11-23 2019-11-24 2019-11-25 2019-11-26 2019-11-27 2019-11-28 2019-11-29 2019-11-30 2019-12-01 
: 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 0 
: [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]
: [(7, 0), (8, 1), (9, 2), (10, 3), (11, 4), (12, 5), (13, 6)]
: [(14, 0), (15, 1), (16, 2), (17, 3), (18, 4), (19, 5), (20, 6)]
: [(21, 0), (22, 1), (23, 2), (24, 3), (25, 4), (26, 5), (27, 6)]
: [(28, 0), (29, 1), (30, 2), (31, 3), (0, 4), (0, 5), (0, 6)]
